#!/usr/bin/env python3
"""
Project CLI - Command Launcher for Agentive Projects
=====================================================

Simple memorable command interface for common project operations.

Usage:
    ./project linearsync     - Sync tasks to Linear
    ./project sync           - Alias for linearsync
    ./project move <id> <status> - Move task and update Status field
    ./project complete <id>  - Move task to done
    ./project validate       - Validate all task statuses
    ./project help           - Show help
"""

import os
import re
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path

# Default version tag for reproducibility
EVALUATOR_LIBRARY_VERSION = "v0.2.2"
EVALUATOR_LIBRARY_REPO = "https://github.com/movito/adversarial-evaluator-library.git"

# Status to folder mapping
STATUS_FOLDER_MAP = {
    "backlog": "1-backlog",
    "todo": "2-todo",
    "in-progress": "3-in-progress",
    "in-review": "4-in-review",
    "done": "5-done",
    "canceled": "6-canceled",
    "blocked": "7-blocked",
}

# Folder to Linear-native status mapping
FOLDER_STATUS_MAP = {
    "1-backlog": "Backlog",
    "2-todo": "Todo",
    "3-in-progress": "In Progress",
    "4-in-review": "In Review",
    "5-done": "Done",
    "6-canceled": "Canceled",
    "7-blocked": "Blocked",
}


def find_task_file(task_id: str, project_dir: Path) -> Path | None:
    """Find a task file by ID across all workflow folders."""
    tasks_dir = project_dir / "delegation" / "tasks"

    # Normalize task ID (handle ASK-0001 or ASK-1)
    task_id_upper = task_id.upper()

    for folder in tasks_dir.iterdir():
        if not folder.is_dir():
            continue
        for file in folder.glob("*.md"):
            if task_id_upper in file.name.upper():
                return file
    return None


def update_status_in_file(file_path: Path, new_status: str) -> bool:
    """Update the Status field in a task file."""
    try:
        content = file_path.read_text()
        # Replace Status field
        new_content = re.sub(
            r"(\*\*Status\*\*:\s*)(\w+(?:\s+\w+)?)",
            f"\\1{new_status}",
            content,
            count=1,
        )
        if new_content != content:
            file_path.write_text(new_content)
            return True
        return False
    except Exception as e:
        print(f"‚ùå Error updating file: {e}")
        return False


def move_task(task_id: str, target_status: str, project_dir: Path) -> bool:
    """Move a task to a new folder and update its Status field."""
    # Normalize target status
    target_lower = target_status.lower().replace("_", "-").replace(" ", "-")

    if target_lower not in STATUS_FOLDER_MAP:
        print(f"‚ùå Unknown status: {target_status}")
        print(f"   Valid statuses: {', '.join(STATUS_FOLDER_MAP.keys())}")
        return False

    target_folder = STATUS_FOLDER_MAP[target_lower]
    linear_status = FOLDER_STATUS_MAP[target_folder]

    # Find the task file
    task_file = find_task_file(task_id, project_dir)
    if not task_file:
        print(f"‚ùå Task not found: {task_id}")
        return False

    # Get current folder
    current_folder = task_file.parent.name

    if current_folder == target_folder:
        print(f"‚ÑπÔ∏è  Task already in {target_folder}")
        # Still update status field if needed
        update_status_in_file(task_file, linear_status)
        return True

    # Move file
    target_dir = project_dir / "delegation" / "tasks" / target_folder
    target_path = target_dir / task_file.name

    try:
        shutil.move(str(task_file), str(target_path))
        print(f"üìÅ Moved: {current_folder} ‚Üí {target_folder}")
    except Exception as e:
        print(f"‚ùå Error moving file: {e}")
        return False

    # Update status field
    if update_status_in_file(target_path, linear_status):
        print(f"‚úèÔ∏è  Updated: **Status**: {linear_status}")

    print(f"‚úÖ Task {task_id} is now {linear_status}")
    return True


def validate_all_tasks(project_dir: Path) -> bool:
    """Validate all task files have matching Status and folder."""
    tasks_dir = project_dir / "delegation" / "tasks"
    errors = []
    checked = 0

    for folder in tasks_dir.iterdir():
        if not folder.is_dir():
            continue
        if folder.name in ["8-archive", "9-reference"]:
            continue
        if folder.name not in FOLDER_STATUS_MAP:
            continue

        expected_status = FOLDER_STATUS_MAP[folder.name]

        for file in folder.glob("*.md"):
            checked += 1
            content = file.read_text()
            match = re.search(r"\*\*Status\*\*:\s*(\w+(?:\s+\w+)?)", content)

            if not match:
                errors.append(f"{file.name}: No Status field found")
                continue

            actual_status = match.group(1).strip()
            if actual_status != expected_status:
                errors.append(
                    f"{file.name}: Status '{actual_status}' != folder '{expected_status}'"
                )

    if errors:
        print(f"‚ùå Found {len(errors)} status mismatches:\n")
        for error in errors:
            print(f"  ‚Ä¢ {error}")
        print(f"\nTo fix, use: ./project move <task-id> <status>")
        return False

    print(f"‚úÖ All {checked} tasks have matching Status and folder")
    return True


def reconfigure_project(project_dir: Path) -> bool:
    """Reconfigure agent files with the correct project name.

    This updates .claude/agents/*.md files, replacing any activate_project()
    calls with the actual project name from .serena/project.yml.

    Handles multiple scenarios:
    - Fresh clone with "your-project" placeholder
    - After upstream merge with "agentive-starter-kit"
    - Any other project name that needs updating

    Useful after fetching upstream updates that overwrite agent files.
    """
    serena_config = project_dir / ".serena" / "project.yml"
    agents_dir = project_dir / ".claude" / "agents"

    # Check .serena/project.yml exists
    if not serena_config.exists():
        print("Error: .serena/project.yml not found")
        print("Run 'agents/launch onboarding' first to configure your project")
        return False

    # Extract project name (supports both 'name:' and 'project_name:')
    project_name = None
    try:
        content = serena_config.read_text()
        for line in content.splitlines():
            # Match top-level name or project_name (no leading whitespace)
            if line.startswith("name:") or line.startswith("project_name:"):
                # Extract value after colon, strip quotes and whitespace
                value = line.split(":", 1)[1].strip().strip("\"'")
                if value:
                    project_name = value
                    break
    except Exception as e:
        print(f"Error reading .serena/project.yml: {e}")
        return False

    if not project_name:
        print("Error: Could not find 'name:' or 'project_name:' in .serena/project.yml")
        print("Check your Serena configuration.")
        return False

    print(f"\nüîß Reconfiguring project: {project_name}\n")
    print("Checking agent files...")

    # Check if agents directory exists
    if not agents_dir.exists():
        print("Warning: No agent files found in .claude/agents/")
        return True  # Success - nothing to do

    # Find and update agent files
    agent_files = list(agents_dir.glob("*.md"))
    if not agent_files:
        print("Warning: No .md files found in .claude/agents/")
        return True  # Success - nothing to do

    updated = 0
    skipped = 0

    # Regex pattern to match any activate_project call
    # This handles both placeholder ("your-project") and upstream ("agentive-starter-kit")
    pattern = re.compile(r'activate_project\("([^"]+)"\)')
    replacement = f'activate_project("{project_name}")'

    for agent_file in sorted(agent_files):
        try:
            content = agent_file.read_text()

            # Find all current project names in the file
            matches = pattern.findall(content)

            if not matches:
                print(f"  ¬∑ {agent_file.name} - no activation calls found")
                skipped += 1
                continue

            # Check if any match is NOT the current project name
            needs_update = any(m != project_name for m in matches)

            if needs_update:
                new_content = pattern.sub(replacement, content)
                agent_file.write_text(new_content)
                old_names = set(m for m in matches if m != project_name)
                print(f"  ‚úì {agent_file.name} - updated (was: {', '.join(old_names)})")
                updated += 1
            else:
                print(f"  ¬∑ {agent_file.name} - already configured")
                skipped += 1
        except Exception as e:
            print(f"  ‚úó {agent_file.name} - error: {e}")

    print(f"\n‚úÖ Reconfigured {updated} files ({skipped} already correct)")
    return True


def get_activate_command(venv_dir: Path) -> str:
    """Return shell-appropriate activate command.

    Detects the user's shell and returns the correct activation script:
    - fish shell: .venv/bin/activate.fish
    - csh/tcsh shell: .venv/bin/activate.csh
    - bash/zsh/sh/others: .venv/bin/activate (default)
    """
    shell = os.environ.get("SHELL", "")
    if "fish" in shell:
        return f"source {venv_dir}/bin/activate.fish"
    elif "csh" in shell or "tcsh" in shell:
        return f"source {venv_dir}/bin/activate.csh"
    else:
        # Default: works for bash, zsh, sh, and most POSIX shells
        return f"source {venv_dir}/bin/activate"


def detect_uv() -> bool:
    """Check if uv is available on the system.

    Returns True if uv is in PATH, False otherwise.
    uv is a modern Python package manager that can auto-install Python versions.
    """
    return shutil.which("uv") is not None


def create_venv_with_uv(venv_dir: Path, python_version: str = "3.12") -> bool:
    """Create a virtual environment using uv with the specified Python version.

    uv will automatically download the Python version if not cached locally.

    Args:
        venv_dir: Path to the virtual environment directory to create.
        python_version: Python version to use (default: "3.12").

    Returns:
        True if venv creation succeeded, False otherwise.
    """
    try:
        result = subprocess.run(
            ["uv", "venv", str(venv_dir), "--python", python_version, "--seed"],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            print(f"‚ö†Ô∏è  uv failed: {result.stderr.strip()}")
            return False
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è  uv error: {e}")
        return False


def cmd_setup(args):
    """Set up virtual environment and install dependencies."""
    project_dir = Path(__file__).resolve().parent.parent
    venv_dir = project_dir / ".venv"
    force = "--force" in args
    use_uv = False  # Flag to track if we need uv for venv creation

    # 1. Verify Python version (3.10+ required, <3.13 due to aider-chat constraint)
    major, minor = sys.version_info[:2]
    version_str = f"{major}.{minor}.{sys.version_info[2]}"

    # Lower bound
    if (major, minor) < (3, 10):
        print(f"‚ùå Python {version_str} is too old")
        print("   Minimum required: Python 3.10")
        print()
        print("   Install a newer Python version:")
        print("   - pyenv: pyenv install 3.12")
        print("   - brew:  brew install python@3.12")
        sys.exit(1)

    # Upper bound (aider-chat constraint: Python <3.13)
    if (major, minor) >= (3, 13):
        if detect_uv():
            # uv is available - we can auto-create a 3.12 venv
            print(f"‚ö†Ô∏è  Python {version_str} detected (requires <3.13)")
            print("   uv found - will create venv with Python 3.12")
            use_uv = True
        else:
            # uv not available - show helpful error with uv as primary recommendation
            print(f"‚ùå Python {version_str} is not yet supported")
            print("   adversarial-workflow requires Python >=3.10,<3.13")
            print("   (constraint from aider-chat dependency)")
            print()
            print("   Recommended: Install uv (auto-manages Python versions)")
            print("   curl -LsSf https://astral.sh/uv/install.sh | sh")
            print("   Then run: ./scripts/project setup")
            print()
            print("   Alternative options:")
            print("   - Use pyenv: pyenv install 3.12 && pyenv local 3.12")
            print("   - Use brew:  brew install python@3.12")
            print("   - Download:  https://www.python.org/downloads/")
            print()
            print("   Then run: python3.12 scripts/project setup")
            sys.exit(1)
    else:
        print(f"‚úÖ Python {version_str}")

    # 2. Handle existing venv
    if venv_dir.exists():
        if force:
            print(f"üóëÔ∏è  Removing existing venv: {venv_dir}")
            try:
                shutil.rmtree(venv_dir)
            except Exception as e:
                print(f"‚ùå Failed to remove venv: {e}")
                print("   Try: rm -rf .venv")
                sys.exit(1)
        else:
            # Verify venv is valid (has python executable)
            venv_python = venv_dir / "bin" / "python"
            if not venv_python.exists():
                print("‚ö†Ô∏è  Corrupted venv detected (missing python)")
                print(
                    "   Run with --force to recreate: ./scripts/project setup --force"
                )
                sys.exit(1)
            # If we need Python 3.12 (use_uv case), verify existing venv has it
            if use_uv:
                try:
                    result = subprocess.run(
                        [
                            str(venv_python),
                            "-c",
                            "import sys; print(f'{sys.version_info[0]}.{sys.version_info[1]}')",
                        ],
                        capture_output=True,
                        text=True,
                    )
                    venv_version = result.stdout.strip()
                    if result.returncode != 0 or not venv_version.startswith("3.12"):
                        print(f"‚ö†Ô∏è  Existing venv uses Python {venv_version}, need 3.12")
                        print(
                            "   Run with --force to recreate: ./scripts/project setup --force"
                        )
                        sys.exit(1)
                except Exception as e:
                    print(f"‚ö†Ô∏è  Could not verify venv Python version: {e}")
                    print(
                        "   Run with --force to recreate: ./scripts/project setup --force"
                    )
                    sys.exit(1)
            print(f"‚úÖ Virtual environment exists: {venv_dir}")
            print("   (use --force to recreate)")

    # 3. Create venv if needed
    if not venv_dir.exists():
        if use_uv:
            # Use uv to create venv with Python 3.12
            print("\nüì¶ Creating virtual environment with uv (Python 3.12)...")
            if create_venv_with_uv(venv_dir, "3.12"):
                print(f"‚úÖ Created venv with Python 3.12 (via uv): {venv_dir}")
            else:
                print("‚ùå Failed to create venv with uv")
                print("   Try manually: uv venv .venv --python 3.12")
                sys.exit(1)
        else:
            # Standard venv creation with system Python
            print("\nüì¶ Creating virtual environment...")
            try:
                result = subprocess.run(
                    [sys.executable, "-m", "venv", str(venv_dir)],
                    capture_output=True,
                    text=True,
                )
                if result.returncode != 0:
                    print(f"‚ùå Failed to create venv: {result.stderr}")
                    sys.exit(1)
                print(f"‚úÖ Created: {venv_dir}")
            except Exception as e:
                print(f"‚ùå Failed to create venv: {e}")
                sys.exit(1)

    # 4. Install dependencies
    pip = venv_dir / "bin" / "pip"
    print("\nüì¶ Installing dependencies...")
    try:
        result = subprocess.run(
            [str(pip), "install", "-e", ".[dev]"],
            capture_output=True,
            text=True,
            cwd=project_dir,
        )
        if result.returncode != 0:
            print("‚ùå Failed to install dependencies:")
            # Show last 500 chars of stderr for debugging
            stderr = result.stderr
            print(stderr[-500:] if len(stderr) > 500 else stderr)
            print("\nTry manually: source .venv/bin/activate && pip install -e '.[dev]'")
            sys.exit(1)
        print("‚úÖ Dependencies installed")
    except Exception as e:
        print(f"‚ùå Failed to install dependencies: {e}")
        sys.exit(1)

    # 5. Install pre-commit hooks (optional - skip if pre-commit not installed)
    pre_commit = venv_dir / "bin" / "pre-commit"
    if pre_commit.exists():
        print("\nüîß Installing pre-commit hooks...")
        try:
            result = subprocess.run(
                [str(pre_commit), "install"],
                capture_output=True,
                text=True,
                cwd=project_dir,
            )
            if result.returncode == 0:
                print("‚úÖ Pre-commit hooks installed")
            else:
                print(f"‚ö†Ô∏è  Pre-commit install failed (non-critical): {result.stderr}")
        except Exception as e:
            print(f"‚ö†Ô∏è  Pre-commit install failed (non-critical): {e}")
    else:
        print("\n‚ö†Ô∏è  pre-commit not found in venv (install manually if needed)")

    # 6. Print success and Next Steps section
    print()
    print("=" * 50)
    print("‚úÖ Setup complete!")
    print("=" * 50)
    print()

    # Check if already in a virtual environment
    if os.environ.get("VIRTUAL_ENV"):
        print("You're already in a virtual environment.")
        print("Run: pip install -e '.[dev]'  # if needed")
    else:
        activate_cmd = get_activate_command(venv_dir)
        print("üìã Next step - activate the virtual environment:")
        print()
        print(f"    {activate_cmd}")
        print()
        print("Then you can run:")
        print("    pytest tests/ -v          # Run tests")
        print("    adversarial --help        # Evaluation CLI")
        print("    ./scripts/project help    # Project commands")


def cmd_install_evaluators(args, project_dir):
    """Install evaluators from adversarial-evaluator-library."""
    # Parse arguments
    force = "--force" in args
    version = EVALUATOR_LIBRARY_VERSION

    # Check for --ref flag (e.g., --ref v0.3.0 or --ref main)
    for i, arg in enumerate(args):
        if arg == "--ref" and i + 1 < len(args):
            version = args[i + 1]
            break

    # 1. Check for git (required for cloning)
    git_check = subprocess.run(
        ["git", "--version"], capture_output=True, text=True
    )
    if git_check.returncode != 0:
        print("‚ùå Git is required but not found")
        print()
        print("Install git:")
        print("  macOS:  brew install git")
        print("  Ubuntu: sudo apt install git")
        print("  Windows: https://git-scm.com/download/win")
        sys.exit(1)

    evaluators_dir = project_dir / ".adversarial" / "evaluators"
    evaluators_dir.mkdir(parents=True, exist_ok=True)

    print("üì¶ Adversarial Evaluator Library Installer")
    print("=" * 50)
    print(f"   Version: {version}")
    print()

    # 2. Check if already installed
    version_file = evaluators_dir / ".installed-version"
    if version_file.exists() and not force:
        installed = version_file.read_text().strip()
        print(f"‚ö†Ô∏è  Evaluators already installed (version: {installed})")
        print("   Use --force to reinstall")
        print("   Use --ref <version> to install a different version")
        return

    # 3. Clone specific version
    with tempfile.TemporaryDirectory() as tmpdir:
        print(f"üì• Cloning evaluator library @ {version}...")
        try:
            result = subprocess.run(
                [
                    "git",
                    "clone",
                    "--depth",
                    "1",
                    "--branch",
                    version,
                    EVALUATOR_LIBRARY_REPO,
                    tmpdir,
                ],
                capture_output=True,
                text=True,
                timeout=60,
            )
        except subprocess.TimeoutExpired:
            print("‚ùå Clone timed out (network issue?)")
            print("   Check your internet connection and try again")
            sys.exit(1)

        if result.returncode != 0:
            if "Could not resolve host" in result.stderr:
                print("‚ùå Network error - check your internet connection")
            elif "not found" in result.stderr.lower():
                print(f"‚ùå Version '{version}' not found")
                print(
                    "   Available versions: "
                    "https://github.com/movito/adversarial-evaluator-library/tags"
                )
            else:
                print(f"‚ùå Failed to clone: {result.stderr.strip()}")
            sys.exit(1)

        # Get actual commit hash for reproducibility
        hash_result = subprocess.run(
            ["git", "-C", tmpdir, "rev-parse", "HEAD"],
            capture_output=True,
            text=True,
        )
        commit_hash = (
            hash_result.stdout.strip()[:8]
            if hash_result.returncode == 0
            else "unknown"
        )

        # Copy evaluators
        src = Path(tmpdir) / "evaluators"
        if not src.exists():
            print("‚ùå No evaluators directory in library")
            sys.exit(1)

        installed_count = 0
        for provider_dir in src.iterdir():
            if provider_dir.is_dir() and provider_dir.name not in (
                "__pycache__",
                ".git",
            ):
                dest = evaluators_dir / provider_dir.name
                if dest.exists():
                    shutil.rmtree(dest)
                shutil.copytree(provider_dir, dest)
                print(f"  ‚úÖ {provider_dir.name}/")
                installed_count += 1

        # Write version file for tracking
        version_file.write_text(f"{version} ({commit_hash})\n")

    print()
    print("=" * 50)
    print(f"‚úÖ Installed {installed_count} provider(s) from {version} ({commit_hash})")
    print()
    print("List evaluators:  adversarial list-evaluators")
    print()
    print("API keys needed (add to .env):")
    print("  OPENAI_API_KEY   - OpenAI evaluators")
    print("  GOOGLE_API_KEY   - Gemini evaluators")
    print("  MISTRAL_API_KEY  - Mistral evaluators")


def main():
    """Launch project commands."""
    # Get the project directory (parent of scripts/)
    project_dir = Path(__file__).resolve().parent.parent

    # Use venv Python if available, otherwise system Python
    venv_python = project_dir / "venv" / "bin" / "python3"
    if not venv_python.exists():
        venv_python = project_dir / ".venv" / "bin" / "python3"
    python_cmd = str(venv_python) if venv_python.exists() else "python3"

    # Show help if no arguments
    if len(sys.argv) == 1:
        print_help()
        sys.exit(0)

    command = sys.argv[1].lower()

    # Handle commands
    if command in ["linearsync", "sync", "linear"]:
        # Linear sync command
        print("üöÄ Syncing tasks to Linear...")
        sync_args = sys.argv[2:] if len(sys.argv) > 2 else []
        cmd = [
            python_cmd,
            str(project_dir / "scripts" / "sync_tasks_to_linear.py"),
        ] + sync_args

    elif command in ["teams", "linearteams"]:
        # List Linear teams
        print("üè¢ Listing Linear teams...")
        cmd = [
            python_cmd,
            "-c",
            """
import os
import sys
from pathlib import Path
from dotenv import load_dotenv
from gql import gql, Client
from gql.transport.requests import RequestsHTTPTransport

# Load .env from project root
env_path = Path.cwd() / '.env'
if env_path.exists():
    load_dotenv(env_path)

api_key = os.getenv('LINEAR_API_KEY')
if not api_key:
    print('‚ùå LINEAR_API_KEY not found in .env')
    print('   Get your key at: https://linear.app/{workspace}/settings/account/security')
    sys.exit(1)

transport = RequestsHTTPTransport(
    url='https://api.linear.app/graphql',
    headers={'Authorization': api_key},
    use_json=True
)

try:
    client = Client(transport=transport, fetch_schema_from_transport=True)
    query = gql('''
        query {
          teams {
            nodes {
              id
              key
              name
            }
          }
        }
    ''')

    result = client.execute(query)
    teams = result['teams']['nodes']

    if not teams:
        print('‚ùå No teams found in Linear workspace')
        sys.exit(1)

    print()
    print('üè¢ Your Linear Teams:')
    print('=' * 70)
    for team in teams:
        print(f"Team: {team['name']}")
        print(f"  Key:  {team['key']}")
        print(f"  UUID: {team['id']}")
        print()

    print('üí° To use a specific team, add to .env:')
    print(f"   LINEAR_TEAM_ID={teams[0]['key']}  # (or any team KEY above)")

except Exception as e:
    print(f'‚ùå Error connecting to Linear: {e}')
    sys.exit(1)
""",
        ]

    elif command in ["help", "-h", "--help"]:
        print_help()
        sys.exit(0)

    elif command == "version":
        print("Project CLI v1.1.0")
        print("Part of Agentive Starter Kit")
        sys.exit(0)

    elif command == "move":
        # Move task to new status folder
        if len(sys.argv) < 4:
            print("Usage: ./scripts/project move <task-id> <status>")
            print("       ./project move ASK-0001 done")
            print(f"       Valid statuses: {', '.join(STATUS_FOLDER_MAP.keys())}")
            sys.exit(1)
        task_id = sys.argv[2]
        target_status = sys.argv[3]
        success = move_task(task_id, target_status, project_dir)
        sys.exit(0 if success else 1)

    elif command == "complete":
        # Shorthand for moving to done
        if len(sys.argv) < 3:
            print("Usage: ./scripts/project complete <task-id>")
            sys.exit(1)
        task_id = sys.argv[2]
        success = move_task(task_id, "done", project_dir)
        sys.exit(0 if success else 1)

    elif command == "start":
        # Shorthand for moving to in-progress
        if len(sys.argv) < 3:
            print("Usage: ./scripts/project start <task-id>")
            sys.exit(1)
        task_id = sys.argv[2]
        success = move_task(task_id, "in-progress", project_dir)
        sys.exit(0 if success else 1)

    elif command == "block":
        # Shorthand for moving to blocked
        if len(sys.argv) < 3:
            print("Usage: ./scripts/project block <task-id>")
            sys.exit(1)
        task_id = sys.argv[2]
        success = move_task(task_id, "blocked", project_dir)
        sys.exit(0 if success else 1)

    elif command == "validate":
        # Validate all task statuses match folders
        success = validate_all_tasks(project_dir)
        sys.exit(0 if success else 1)

    elif command == "reconfigure":
        # Reconfigure agent files with project name
        success = reconfigure_project(project_dir)
        sys.exit(0 if success else 1)

    elif command == "setup":
        # Set up virtual environment and install dependencies
        cmd_setup(sys.argv[2:])
        sys.exit(0)

    elif command == "install-evaluators":
        # Install evaluators from adversarial-evaluator-library
        cmd_install_evaluators(sys.argv[2:], project_dir)
        sys.exit(0)

    elif command == "sync-status":
        # Check Linear sync status
        print("üîç Checking Linear sync status...")
        cmd = [
            python_cmd,
            "-c",
            """
import os
import sys
from pathlib import Path
from datetime import datetime

# Try to load .env file if it exists
try:
    from dotenv import load_dotenv
    env_path = Path.cwd() / '.env'
    if env_path.exists():
        load_dotenv(env_path)
except ImportError:
    pass

# Import gql for GraphQL operations
try:
    from gql import gql, Client
    from gql.transport.requests import RequestsHTTPTransport
except ImportError:
    print('‚ùå Error: gql package not installed')
    print('   Run: pip install gql[requests]')
    sys.exit(1)

# Check environment
api_key = os.getenv('LINEAR_API_KEY')
if not api_key:
    print('‚ùå LINEAR_API_KEY not found in .env')
    print('   Get your key at: https://linear.app/{workspace}/settings/account/security')
    sys.exit(1)

# Count local tasks
tasks_dir = Path('delegation/tasks')
workflow_folders = [
    '1-backlog', '2-todo', '3-in-progress', '4-in-review',
    '5-done', '6-canceled', '7-blocked'
]

local_tasks = []
for folder in workflow_folders:
    folder_path = tasks_dir / folder
    if folder_path.exists():
        # Match any task format: PREFIX-NNNN-description.md (e.g., TASK-0001, ASK-0001, TC2-0001)
        local_tasks.extend(list(folder_path.glob('*-[0-9]*.md')))

local_count = len(local_tasks)

# Get Linear issues
transport = RequestsHTTPTransport(
    url='https://api.linear.app/graphql',
    headers={'Authorization': api_key},
    use_json=True
)

try:
    client = Client(transport=transport, fetch_schema_from_transport=True)

    # Get team ID
    team_id = os.getenv('LINEAR_TEAM_ID')
    if team_id and '-' not in team_id:
        # It's a team key, need to look up UUID
        teams_query = gql('''
            query {
              teams { nodes { id key name } }
            }
        ''')
        result = client.execute(teams_query)
        for team in result['teams']['nodes']:
            if team['key'] == team_id:
                team_id = team['id']
                break

    if not team_id:
        # Get default team
        teams_query = gql('''
            query {
              teams { nodes { id name } }
            }
        ''')
        result = client.execute(teams_query)
        teams = result['teams']['nodes']
        if not teams:
            print('‚ùå No teams found in Linear workspace')
            sys.exit(1)
        team_id = teams[0]['id']

    # Query issues for this team with updatedAt for last sync time
    issues_query = gql('''
        query TeamIssues($teamId: String!) {
          team(id: $teamId) {
            name
            issues {
              nodes {
                identifier
                title
                state { name }
                updatedAt
              }
            }
          }
        }
    ''')

    result = client.execute(issues_query, variable_values={'teamId': team_id})
    team_name = result['team']['name']
    issues = result['team']['issues']['nodes']
    linear_count = len(issues)

    # Find last sync time (most recent updatedAt)
    last_sync = None
    if issues:
        timestamps = [issue['updatedAt'] for issue in issues]
        timestamps.sort(reverse=True)
        last_sync = timestamps[0]

    # Compare counts
    print()
    print('Linear Sync Status')
    print('==================')
    print(f'Team: {team_name}')
    print(f'Local tasks:   {local_count}')
    print(f'Linear issues: {linear_count}')
    print()

    if local_count == linear_count:
        print('Status: ‚úÖ In sync')
    elif local_count > linear_count:
        diff = local_count - linear_count
        print(f'Status: ‚ö†Ô∏è  Mismatch detected ({diff} missing in Linear)')
        print()
        # Find which tasks might be missing
        linear_ids = set()
        for issue in issues:
            # Extract task ID from title like "[ASK-0001] Title"
            title = issue['title']
            if title.startswith('[') and ']' in title:
                task_id = title[1:title.index(']')]
                linear_ids.add(task_id)

        local_ids = set()
        for task_file in local_tasks:
            # Extract task ID from filename like ASK-0001-description.md
            name = task_file.stem
            if '-' in name:
                parts = name.split('-')
                if len(parts) >= 2:
                    task_id = f'{parts[0]}-{parts[1]}'
                    local_ids.add(task_id)

        missing = local_ids - linear_ids
        if missing:
            print(f'Missing in Linear: {", ".join(sorted(missing)[:5])}')
            if len(missing) > 5:
                print(f'  ... and {len(missing) - 5} more')
        print()
        print('Run: ./project linearsync')
    else:
        diff = linear_count - local_count
        print(f'Status: ‚ö†Ô∏è  Mismatch detected ({diff} extra in Linear)')
        print()
        print('Note: Linear has more issues than local tasks.')
        print('This may be normal if issues were created directly in Linear.')

    print()
    if last_sync:
        # Parse ISO timestamp and format nicely
        try:
            dt = datetime.fromisoformat(last_sync.replace('Z', '+00:00'))
            formatted = dt.strftime('%Y-%m-%d %H:%M:%S UTC')
            print(f'Last sync: {formatted}')
        except Exception:
            print(f'Last sync: {last_sync}')

except Exception as e:
    print(f'‚ùå Error connecting to Linear: {e}')
    sys.exit(1)
""",
        ]

    else:
        print(f"‚ùå Unknown command: {command}")
        print("Run './project help' for available commands.")
        sys.exit(1)

    # Run the command from project directory
    try:
        result = subprocess.run(cmd, cwd=project_dir)
        sys.exit(result.returncode)
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Error running command: {e}")
        sys.exit(1)
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è  Operation cancelled by user")
        sys.exit(0)
    except FileNotFoundError:
        print(f"‚ùå Python not found at: {python_cmd}")
        print("   Make sure you have a virtual environment set up:")
        print("   python3 -m venv venv && source venv/bin/activate")
        sys.exit(1)


def print_help():
    """Print help message."""
    print(
        """
Project CLI - Agentive Starter Kit
==================================

Usage: ./scripts/project <command> [options]

Setup:
  setup [--force]        Create venv and install dependencies
  install-evaluators     Install evaluators from adversarial-evaluator-library
                         Options: --force (reinstall), --ref <tag> (version)

Task Management:
  move <id> <status>   Move task to folder and update Status field
  complete <id>        Move task to done (shorthand)
  start <id>           Move task to in-progress (shorthand)
  block <id>           Move task to blocked (shorthand)
  validate             Validate all task statuses match folders

Configuration:
  reconfigure          Update agent files with project name after upstream merge

Linear Sync:
  linearsync, sync     Sync task files to Linear
  sync-status          Check if local tasks match Linear issues
  teams                List all Linear teams

Other:
  help                 Show this help message
  version              Show version information

Examples:
  ./project complete ASK-0001    Move task to done, update Status
  ./project move ASK-0002 todo   Move task to todo folder
  ./project validate             Check all statuses match folders
  ./project reconfigure          Update agents after pulling upstream
  ./project linearsync           Sync all tasks to Linear

Valid statuses for 'move':
  backlog, todo, in-progress, in-review, done, canceled, blocked

For more information, see README.md
"""
    )


if __name__ == "__main__":
    main()
